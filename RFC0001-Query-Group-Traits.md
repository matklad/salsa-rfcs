# Motivation

- Support `dyn QueryGroup` for each query group trait as well as `impl QueryGroup`
  - `dyn QueryGroup` will be much more convenient, at the cost of runtime efficiency
- Don't require you to redeclare each query in the final database, just the query groups
- Support generic parameters (not directly related, just an auxiliary concern)

# User's guide

## Declaring a query group

User's will declare query groups by decorating a trait:

```rust
#[salsa::query_group]
trait MyGroup<P0..Pn> where WC {
  // Inputs are declared as a pair of a getter and a setter.
  //
  // Setters have `&mut self` and must have a name `set_X` where `X` is the name of
  // some other `&self` method (and of course the keys/values must have compatible types).
  fn my_input(&self, key: K1) -> V1;
  fn set_my_input(&mut self, key: K1, value: V1);
  
  // "Derived" queries are just a getter.
  fn my_query(&self, key: K2) -> V2;
}
```

This will invoke a procedural macro which will generate, in addition
to the trait declaration, a number of types. For the most part, users
do not have to interact with these types, and their names are
automatically generated by the macro. The types (and their names) are
as follows:

- `MyGroupGroupStorage` -- this is a struct that, at runtime, holds the memoized
  data for all the queries defined in the query group. The default name is
  derived by appending `GroupStorage` to the name of the trait.
- `MyInputQuery`, `MyQueryQuery` -- these structs represent the
  queries themselves and do not contain data at runtime. They are only
  used to identify queries in the Salsa APIs. The default name is
  derived by (a) converting the method name from `snake_case` to
  `CamelCase` and then (b) appending the string `Query`.
- `MyGroupGroupDescriptor` -- this is an enum that has a variant for
  each query along with the keys of that query. The default name is
  generated by appending `GroupDescriptor` to the name of the trait.
  
At present, the names cannot be customized, but we may add attributes
later to permit such customization.
  
### Controlling query modes

Derived queries can be customized by the following attributes,
attached to the getter method (e.g., `fn my_query(..)`):

- `#[salsa::invoke(foo::bar)]` specifies the path to the function to invoke
  when the query is called (default is `my_query`).
- `#[salsa::volatile]` specifies a "volatile" query, which is assumed to
  read untracked input and hence must be re-executed on every revision.

## Creating the database

Creating a salsa database works by using the `database_storage` macro,
as today. Unlike today, the only requirement is to give the name of
the struct and the query groups that it implements. It is no longer
necessary to list the individual queries.

```rust
struct MyDatabase {
  runtime: salsa::Runtime<MyDatabase>,
}

salsa::database_storage! {
    MyDatabase {
      MyGroup, // .. other groups may be listed here ..
    }
}    
```

This (procedural) macro also generates a type with an automatic
name. Users do not typically have to interact with this type:

- `MyDatabaseDatabaseDescriptor` -- an enum with one variant for each group
  that stores the group descriptor.

# Reference guide

## Lowering query groups

The trait definition will be lowered as follows. First, we will create
the exact trait given by the user, except without any salsa-specific
annotations. Next, we will create a series of structs and impls,
specified here.

### The group storage struct

We will create a `struct MyGroupGroupStorage`. For the trait above, it would
look as follows:

```rust
struct MyGroupGroupStorage<DB, P0..Pn> where WC1 {
  //                           ^^^^^^        ^^^
  //                Parameters from trait.  Where clauses from the
  //                                        trait, adjusted as
  //                                        described below.
  
  my_input: <MyInputQuery<P0..Pn> as salsa::plumbing::Query<DB>>::Storage,
  my_query: <MyQueryQuery<P0..Pn> as salsa::plumbing::Query<DB>>::Storage,
}
```

The types `MyInputQuery` and `MyQueryQuery` are also generated by the
macro, as described below.

Note that this struct is parameterized by the lifetime/type parameters
`P0..Pn` that appear on the trait, as well as one additional parameter
`DB`. This parameter `DB` represents the "Self" type of the trait --
it is the database type that is ultimately in use. The where clauses
`WC1` represent the where clauses from the trait, but with references
to `Self` replaced with `DB`.

(In the actual implementation, the ideal would be for the name `DB` to
use a distinct hygiene setup so that it is "private" to the struct and
does not clash with the names the user gave in `P0..Pn`. Since hygiene
is not yet stable, we can actually just use `__DB` or something like
that in the real implementation.)

### The group descriptor 

The group descriptor is an enum that stores one of the queries in the
group along with its key:

```rust
enum MyGroupGroupDescriptor<DB, P0..Pn> where WC1 {
  MyInput(<MyInputQuery<P0..Pn> as salsa::plumbing::Query<DB>>::Key),
  MyQuery(<MyQueryQuery<P0..Pn> as salsa::plumbing::Query<DB>>::Key),
}
```

The type parameters (`DB`, `P0..Pn`) and where clauses (`WC1`) are the
same as were described in the "group storage struct" section.

The group descriptor types must also implement the `salsa::plumbing::QueryDescriptor`
trait. This implement looks something like this:

```rust
impl<DB, P0..Pn> salsa::plumbing::QueryDescriptor<DB>
for __SalsaQueryDescriptor<P0..Pn> 
where 
  WC1,
{
    fn maybe_changed_since(
        &self,
        db: &MyDatabase<P0..Pn>,
        revision: salsa::plumbing::Revision,
    ) -> bool {
        match self {
          MyGroupGroupDescriptor::MyInput(key) => {
            // invoke the `maybe_changed_since` method from
            // `QueryStorageOps` trait, as today
          }
          ..
        }
    }
}    
```

### The impl

We will also generate a blanket impl for the query group trait, as
shown below (again, the type parameters (`DB`, `P0..Pn`) and where
clauses (`WC1`) are the same as were described in the "group storage
struct" section):

```rust
impl<DB, P0..Pn> MyGroup<P0..Pn> for DB
where
  DB: salsa::HasGroupStorage<
    MyGroupGroupStorage<DB, P0..Pn>,
    MyGroupGroupDescriptor<DB, P0..Pn>,
  >,
  WC1,
{
  fn my_input(&self, key: K1) -> V1 {
    let descriptor = MyGroupGroupDescriptor::MyInput(key.clone());
    salsa::plumbing::HasGroupStorage::group_storage(self).my_input.try_fetch(self, descriptor, key)
  }

  fn set_my_input(&mut self, key: K1, value: V1) {
    let descriptor = MyGroupGroupDescriptor::MyInput(key.clone());
    salsa::plumbing::HasGroupStorage::group_storage(self).my_input.set(
      self, 
      descriptor, 
      key, 
      value,
    )
  }
  
  fn my_query(&self, key: K2) -> V2 {
    let descriptor = MyGroupGroupDescriptor::MyQuery(key.clone());
    salsa::plumbing::HasGroupStorage::group_storage(self).my_query.try_fetch(self, descriptor, key)
  }
}
```

This impl references the `plumbing::HasGroupStorage<T>` trait, defined in Salsa
as follows:

```rust
trait HasGroupStorage<GS, GD>: salsa::Database {
  fn group_storage(db: &Self) -> &GS;
  fn db_descriptor(group_descriptor: GD) -> Self::QueryDescriptor;
}
```

NB: This trait is not meant to be used by end-users. It does not use
method form (`&self`) because it is meant to be annoying. Note also
that it *only* gives back `&self` access. This is because

### The query types

For each query `my_query`, we generate a struct that represents the
query as follows:

```rust
struct MyQueryQuery<P0..Pn> {
  data: PhantomData<P0..Pn>
}
```

Note that the struct carries the parameters `P0..Pn` from the trait
but not the where-clauses. This is because the where-clauses cannot be
represented in full without the `DB` type. It carries a phantom data
that captures the parameters.

The query struct also implements the `salsa::Query` trait:

```rust
impl<DB, P0..Pn> salsa::Query<DB> for MyQueryQuery<P0..Pn> 
where
  DB: salsa::Database,
  WC1,
{
  type Key = K;
  type Value = V;
  type Storage = salsa::plumbing::SomeStorage<Self>;
}
```

## Lowering database storage

Given a declaration like

```rust
salsa::database_storage! {
    $v:vis MyDatabase<P0..Pn> {
      path::to::MyGroup0<Q0..Qn>,
      path::to::MyGroup1<R0..Rn>,
      // .. other groups may be listed here ..
    }
}    
```

we will create the following things.

### Database query descriptor

The database query descriptor contains one variant per group.  Its
name is formed by appending `DatabaseDescriptor` to the name of the
database struct. The data for each variant is the "group descriptor",
formed by appending `GroupDescriptor` to the path that leads to the
group. The name of the variant can just use the index of the group in the list.

```rust
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
$v enum MyDatabaseDatabaseDescriptor<P0..Pn> {
  Group0(path::to::MyGroup0GroupDescriptor<MyDatabase<P0..Pn>, Q0..Qn>),
  Group1(path::to::MyGroup1GroupDescriptor<MyDatabase<P0..Pn>, R0..Rn>),
  ..
}
```

The `#[derive]` above is meant only to indicate the traits that must
be implemented.  The `Debug` impl in particular ought not to be
derived because it will generate output that includes `Group0` and
`Group1` rather than the names of the groups. Ideally, debug output
for a query descriptor like (e.g.) `my_query` in `MyGroup` would be
something like `MyGroup::my_query(K)`.

The `MyDatabaseDatabaseDescriptor` type must also implement the
`salsa::plumbing::QueryDescriptor` trait. This just delegates
to the group query descriptor implementations:

```rust
impl<P0..Pn> salsa::plumbing::QueryDescriptor<MyDatabase<P0..Pn>> 
for __SalsaQueryDescriptor<P0..Pn> {
    fn maybe_changed_since(
        &self,
        db: &MyDatabase<P0..Pn>,
        revision: salsa::plumbing::Revision,
    ) -> bool {
        match self {
          MyDatabaseDatabaseDescriptor::Group0(d) => d.maybe_changed_since(db, revision),
          ..
        }
    }
}    
```

### Database storage types impl

Next, we generate an impl of the `DatabaseStorageTypes` trait from
`salsa::plumbing`:

```rust
impl<P0..Pn> salsa::plumbing::DatabaseStorageTypes for MyDatabase<P0..Pn> {
    type QueryDescriptor = MyDatabaseDatabaseDescriptor<P0..Pn>;
    type DatabaseStorage = (
      path::to::MyGroup0GroupStorage<Self, Q0..Qn>,
      path::to::MyGroup1GroupStorage<Self, R0..Rn>,
    );
}
```

Note that the database storage can be a tuple concatenating the group
storage from each group.

### `HasGroupStorage` implementations

For each group, we will implement the `HasGroupStorage` trait. This
trait impl serves to link up the group storage into the greater
context.

```rust
impl<P0..Pn> salsa::plumbing::HasGroupStorage<
  path::to::MyGroup0GroupStorage<Self, Q0..Qn>,
  path::to::MyGroup0GroupDescriptor<Self, R0..Rn>,
> for MyDatabase<P0..Pn> {
  fn group_storage(db: &Self) -> &path::to::MyGroup0GroupStorage<Self, Q0..Qn> {
    let runtime = salsa::Database::salsa_runtime(db);
    &runtime.storage().0 // index of group
  }

  fn db_descriptor(
    group_descriptor: path::to::MyGroup0GroupDescriptor<Self, Q0..Qn>,
  ) -> Self::QueryDescriptor {
    MyDatabaseDatabaseDescriptor::Group0(group_descriptor)
  }
}
```

# Alternatives and future work

There are some downsides to this proposal.

## Efficiency

The query descriptors wind up with two discriminants: one to identify
the group, and one to identify the query. That's a bit sad.
